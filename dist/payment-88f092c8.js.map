{"version":3,"file":"payment-88f092c8.js","mappings":"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","sources":["webpack://checkout/./packages/core/src/app/ui/modal/ModalLink.tsx","webpack://checkout/./packages/core/src/app/ui/text/MultiLineText.tsx","webpack://checkout/./packages/core/src/app/termsConditions/TermsConditionsField.tsx","webpack://checkout/./packages/core/src/app/payment/mapSubmitOrderErrorMessage.ts","webpack://checkout/./packages/core/src/app/payment/creditCard/unformatCreditCardExpiryDate.ts","webpack://checkout/./packages/core/src/app/payment/paymentMethod/getUniquePaymentMethodId.ts","webpack://checkout/./packages/core/src/app/payment/paymentMethod/CreditCardFieldsetValues.ts","webpack://checkout/./packages/core/src/app/payment/mapToOrderRequestBody.ts","webpack://checkout/./packages/core/src/app/payment/creditCard/unformatCreditCardNumber.ts","webpack://checkout/./packages/core/src/app/payment/PaymentContext.tsx","webpack://checkout/./packages/core/src/app/termsConditions/TermsConditions.tsx","webpack://checkout/./packages/core/src/app/payment/getPaymentValidationSchema.ts","webpack://checkout/./packages/core/src/app/termsConditions/getTermsConditionsValidationSchema.ts","webpack://checkout/./packages/core/src/app/payment/paymentMethod/PaymentMethodType.ts","webpack://checkout/./packages/core/src/app/payment/paymentMethod/getPaymentMethodName.ts","webpack://checkout/./packages/core/src/app/payment/PaymentSubmitButton.tsx","webpack://checkout/./packages/core/src/app/payment/SpamProtectionField.tsx","webpack://checkout/./packages/core/src/app/payment/PaymentForm.tsx","webpack://checkout/./packages/core/src/app/payment/paymentMethod/PaymentMethodProviderType.ts","webpack://checkout/./packages/core/src/app/payment/Payment.tsx","webpack://checkout/./packages/core/src/app/common/error/isCartChangedError.ts","webpack://checkout/./packages/core/src/app/ui/modal/ModalTrigger.tsx"],"sourcesContent":["import React, { FunctionComponent, ReactNode, useCallback } from 'react';\r\n\r\nimport { preventDefault } from '@bigcommerce/checkout/dom-utils';\r\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\r\n\r\nimport { Button, ButtonSize } from '../button';\r\n\r\nimport Modal from './Modal';\r\nimport './ModalLink.scss';\r\nimport ModalTrigger, { ModalTriggerModalProps } from './ModalTrigger';\r\n\r\nexport interface ModalLinkProps {\r\n    header: ReactNode;\r\n    body: ReactNode;\r\n}\r\n\r\nconst ModalLink: FunctionComponent<ModalLinkProps> = ({ children, body, header }) => {\r\n    const renderModal = useCallback(\r\n        (props: ModalTriggerModalProps) => (\r\n            <Modal\r\n                {...props}\r\n                additionalBodyClassName=\"modal--withText\"\r\n                footer={\r\n                    <Button onClick={props.onRequestClose} size={ButtonSize.Small}>\r\n                        <TranslatedString id=\"common.ok_action\" />\r\n                    </Button>\r\n                }\r\n                header={header}\r\n                shouldShowCloseButton={true}\r\n            >\r\n                {body}\r\n            </Modal>\r\n        ),\r\n        [header, body],\r\n    );\r\n\r\n    return (\r\n        <ModalTrigger modal={renderModal}>\r\n            { }\r\n            {({ onClick }) => <a onClick={preventDefault(onClick)}>{children}</a>}\r\n        </ModalTrigger>\r\n    );\r\n};\r\n\r\nexport default ModalLink;\r\n","import React, { Fragment, FunctionComponent } from 'react';\r\n\r\nconst MultiLineText: FunctionComponent<{ children: string }> = ({ children }) => (\r\n    <>\r\n        {children.split('\\n').map((line, key) => (\r\n            <Fragment key={key}>\r\n                {line}\r\n                <br />\r\n            </Fragment>\r\n        ))}\r\n    </>\r\n);\r\n\r\nexport default MultiLineText;\r\n","import { FieldProps } from 'formik';\r\nimport React, { FunctionComponent, memo, useCallback, useMemo } from 'react';\r\n\r\nimport { parseAnchor } from '@bigcommerce/checkout/dom-utils';\r\nimport { TranslatedHtml, TranslatedString, withLanguage, WithLanguageProps } from '@bigcommerce/checkout/locale';\r\n\r\nimport { CheckboxFormField, Fieldset, FormField, Legend, TextArea } from '../ui/form';\r\nimport { ModalHeader, ModalLink } from '../ui/modal';\r\nimport { MultiLineText } from '../ui/text';\r\n\r\nexport enum TermsConditionsType {\r\n    Link = 'link',\r\n    TextArea = 'textarea',\r\n    Modal = 'modal',\r\n}\r\n\r\nexport type TermsConditionsFieldProps =\r\n    | TermsConditionsLinkFieldProps\r\n    | TermsConditionsTextAreaFieldProps;\r\n\r\ninterface TermsConditionsLinkFieldProps {\r\n    name: string;\r\n    type: TermsConditionsType.Link;\r\n    url: string;\r\n}\r\n\r\ninterface TermsConditionsTextAreaFieldProps {\r\n    name: string;\r\n    terms: string;\r\n    type: TermsConditionsType.TextArea | TermsConditionsType.Modal;\r\n}\r\n\r\ninterface TermsConditionsTextFieldProps {\r\n    name: string;\r\n    terms: string;\r\n}\r\n\r\nconst BaseTermsConditionsModalCheckboxField: FunctionComponent<\r\n    TermsConditionsTextFieldProps & WithLanguageProps\r\n> = ({ language, name, terms }) => {\r\n    const translatedLabel = language.translate('terms_and_conditions.agreement_with_link_text', {\r\n        url: '',\r\n    });\r\n    const parsedLabel = parseAnchor(translatedLabel);\r\n\r\n    const labelContent = parsedLabel ? (\r\n        <>\r\n            {parsedLabel[0]}\r\n            <ModalLink\r\n                body={<MultiLineText>{terms}</MultiLineText>}\r\n                header={\r\n                    <ModalHeader>\r\n                        <TranslatedString id=\"terms_and_conditions.heading\" />\r\n                    </ModalHeader>\r\n                }\r\n            >\r\n                {parsedLabel[1]}\r\n            </ModalLink>\r\n            {parsedLabel[2]}\r\n        </>\r\n    ) : (\r\n        translatedLabel\r\n    );\r\n\r\n    return <CheckboxFormField labelContent={labelContent} name={name} />;\r\n};\r\n\r\nconst TermsConditionsModalCheckboxField = withLanguage(BaseTermsConditionsModalCheckboxField);\r\n\r\ninterface TermsConditionsCheckboxFieldProps {\r\n    name: string;\r\n    type: TermsConditionsType;\r\n    url?: string;\r\n}\r\n\r\nconst TermsConditionsCheckboxField: FunctionComponent<TermsConditionsCheckboxFieldProps> = ({\r\n    name,\r\n    url,\r\n}) => {\r\n    const labelContent = useMemo(\r\n        () =>\r\n            url ? (\r\n                <TranslatedHtml data={{ url }} id=\"terms_and_conditions.agreement_with_link_text\" />\r\n            ) : (\r\n                <TranslatedString id=\"terms_and_conditions.agreement_text\" />\r\n            ),\r\n        [url],\r\n    );\r\n\r\n    return <CheckboxFormField labelContent={labelContent} name={name} />;\r\n};\r\n\r\nconst TermsConditionsTextField: FunctionComponent<TermsConditionsTextFieldProps> = ({\r\n    name,\r\n    terms,\r\n}) => {\r\n    const renderInput = useCallback(\r\n        ({ field }: FieldProps) => <TextArea defaultValue={terms} name={field.name} readOnly />,\r\n        [terms],\r\n    );\r\n\r\n    return <FormField input={renderInput} name={`${name}Text`} />;\r\n};\r\n\r\nconst TermsConditionsFieldset: FunctionComponent<TermsConditionsFieldProps> = (props) => {\r\n    const { type } = props;\r\n\r\n    return (\r\n        <Fieldset\r\n            additionalClassName=\"checkout-terms\"\r\n            legend={\r\n                <Legend>\r\n                    <TranslatedString id=\"terms_and_conditions.terms_and_conditions_heading\" />\r\n                </Legend>\r\n            }\r\n        >\r\n            {isTermsConditionsTextArea(props) && <TermsConditionsTextField {...props} />}\r\n            {isTermsConditionModal(props) && type === TermsConditionsType.Modal ? (\r\n                <TermsConditionsModalCheckboxField {...props} />\r\n            ) : (\r\n                <TermsConditionsCheckboxField {...props} />\r\n            )}\r\n        </Fieldset>\r\n    );\r\n};\r\n\r\nfunction isTermsConditionsTextArea(props: any): props is TermsConditionsTextFieldProps {\r\n    return props.type === TermsConditionsType.TextArea;\r\n}\r\n\r\nfunction isTermsConditionModal(props: any): props is TermsConditionsTextFieldProps {\r\n    return props.type === TermsConditionsType.Modal;\r\n}\r\n\r\nexport default memo(TermsConditionsFieldset);\r\n","import { TranslationData } from '@bigcommerce/checkout-sdk';\r\nimport { includes } from 'lodash';\r\n\r\nexport default function mapSubmitOrderErrorMessage(\r\n    error: any,\r\n    translate: (key: string, data?: TranslationData) => string,\r\n    shouldLocalise: boolean,\r\n): string {\r\n    switch (error.type) {\r\n        case 'not_initialized':\r\n            return translate('payment.payment_error');\r\n\r\n        case 'custom_provider_execute_error':\r\n            return translate(error.subtype);\r\n\r\n        case 'payment_cancelled':\r\n            return translate('payment.payment_cancelled');\r\n\r\n        case 'payment_method_invalid':\r\n            return translate('payment.payment_method_disabled_error');\r\n\r\n        case 'tax_provider_unavailable':\r\n            return translate('payment.tax_provider_unavailable');\r\n\r\n        case 'cart_changed':\r\n            return translate('shipping.cart_change_error');\r\n\r\n        case 'cart_consistency':\r\n            return translate('cart.consistency_error');\r\n\r\n        default:\r\n            if (\r\n                includes(\r\n                    [\r\n                        'order_could_not_be_finalized_error',\r\n                        'provider_fatal_error',\r\n                        'payment_invalid',\r\n                        'provider_error',\r\n                        'provider_widget_error',\r\n                        'user_payment_error',\r\n                    ],\r\n                    error.body && error.body.type,\r\n                )\r\n            ) {\r\n                return translate('payment.payment_method_error', { message: error.message });\r\n            }\r\n\r\n            if (shouldLocalise && error.body && error.body.errors && error.body.errors.length) {\r\n                const messages = error.body.errors.map((err: { code: any }) =>\r\n                    translate(`payment.errors.${err.code}`),\r\n                );\r\n\r\n                return messages.join(' ');\r\n            }\r\n\r\n            if (error.message) {\r\n                return error.message;\r\n            }\r\n\r\n            return error.type === 'unrecoverable'\r\n                ? translate('common.unavailable_error')\r\n                : translate('payment.place_order_error');\r\n    }\r\n}\r\n\r\nexport function mapSubmitOrderErrorTitle(\r\n    error: any,\r\n    translate: (key: string, data?: TranslationData) => string,\r\n): string {\r\n    if (error.type === 'unrecoverable') {\r\n        return translate('common.unavailable_heading');\r\n    }\r\n\r\n    return translate('common.error_heading');\r\n}\r\n","export interface ExpiryDate {\r\n    month: string;\r\n    year: string;\r\n}\r\n\r\nexport default function unformatCreditCardExpiryDate(value: string): ExpiryDate {\r\n    const separator = '/';\r\n    const [month = '', year = ''] = value.split(new RegExp(`\\\\s*${separator}\\\\s*`));\r\n\r\n    if (!/^\\d+$/.test(month) || !/^\\d+$/.test(year)) {\r\n        return { month: '', year: '' };\r\n    }\r\n\r\n    return {\r\n        month: month.length === 1 ? `0${month}` : month.slice(0, 2),\r\n        year: year.length === 2 ? `20${year}` : year.slice(0, 4),\r\n    };\r\n}\r\n","import { compact } from 'lodash';\r\n\r\nexport default function getUniquePaymentMethodId(methodId: string, gatewayId?: string): string {\r\n    return compact([gatewayId, methodId]).join('-');\r\n}\r\n\r\nexport function parseUniquePaymentMethodId(value: string): {\r\n    methodId: string;\r\n    gatewayId?: string;\r\n} {\r\n    const [gatewayId, methodId] = value.indexOf('-') > -1 ? value.split('-') : [undefined, value];\r\n\r\n    return { gatewayId, methodId };\r\n}\r\n","import { CardInstrumentFieldsetValues } from '../storedInstrument';\r\n\r\nexport default interface CreditCardFieldsetValues {\r\n    ccCustomerCode?: string;\r\n    ccCvv?: string;\r\n    ccExpiry: string;\r\n    ccName: string;\r\n    ccNumber: string;\r\n    shouldSaveInstrument?: boolean;\r\n}\r\n\r\nexport interface CreditCardValidationValues extends CardInstrumentFieldsetValues {\r\n    ccCvv?: string;\r\n    ccNumber?: string;\r\n}\r\n\r\nexport function hasCreditCardNumber(values: unknown): values is { ccNumber: string } {\r\n    if (!(values instanceof Object)) {\r\n        return false;\r\n    }\r\n\r\n    return 'ccNumber' in values;\r\n}\r\n\r\nexport function hasCreditCardExpiry(values: unknown): values is { ccExpiry: string } {\r\n    if (!(values instanceof Object)) {\r\n        return false;\r\n    }\r\n\r\n    return 'ccExpiry' in values;\r\n}\r\n","import { OrderPaymentRequestBody, OrderRequestBody } from '@bigcommerce/checkout-sdk';\r\nimport { isEmpty, isNil, omitBy } from 'lodash';\r\n\r\nimport { PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\r\n\r\nimport { unformatCreditCardExpiryDate, unformatCreditCardNumber } from './creditCard';\r\nimport {\r\n    hasCreditCardExpiry,\r\n    hasCreditCardNumber,\r\n    parseUniquePaymentMethodId,\r\n} from './paymentMethod';\r\n\r\nexport default function mapToOrderRequestBody(\r\n    values: PaymentFormValues,\r\n    isPaymentDataRequired: boolean,\r\n): OrderRequestBody {\r\n    if (!isPaymentDataRequired) {\r\n        return {};\r\n    }\r\n\r\n    const { paymentProviderRadio, ...rest } = values;\r\n    const { methodId, gatewayId } = parseUniquePaymentMethodId(paymentProviderRadio);\r\n    const payload: OrderRequestBody = {\r\n        payment: { gatewayId, methodId },\r\n    };\r\n    const paymentData = omitBy(\r\n        {\r\n            ...rest,\r\n            ccExpiry: hasCreditCardExpiry(values)\r\n                ? unformatCreditCardExpiryDate(values.ccExpiry)\r\n                : null,\r\n            ccNumber: hasCreditCardNumber(values)\r\n                ? unformatCreditCardNumber(values.ccNumber)\r\n                : null,\r\n        },\r\n        isNil,\r\n    ) as OrderPaymentRequestBody['paymentData'];\r\n\r\n    if (payload.payment && !isEmpty(paymentData)) {\r\n        payload.payment.paymentData = paymentData;\r\n    }\r\n\r\n    return payload;\r\n}\r\n","import { number } from 'card-validator';\r\n\r\nexport default function unformatCreditCardNumber(value: string, separator = ' '): string {\r\n    const { card } = number(value);\r\n\r\n    if (!card) {\r\n        return value;\r\n    }\r\n\r\n    return value.replace(new RegExp(separator, 'g'), '');\r\n}\r\n","import { PaymentMethod } from '@bigcommerce/checkout-sdk';\r\nimport { createContext } from 'react';\r\nimport { ObjectSchema } from 'yup';\r\n\r\nimport { PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\r\n\r\nexport interface PaymentContextProps {\r\n    disableSubmit(method: PaymentMethod, disabled?: boolean): void;\r\n    // NOTE: This prop allows certain payment methods to override the default\r\n    // form submission behaviour. It is not recommended to use it because\r\n    // generally speaking we want to avoid method-specific snowflake behaviours.\r\n    // Nevertheless, because of some product / UX decisions made in the past\r\n    // (i.e.: Amazon), we have to have this backdoor so we can preserve these\r\n    // snowflake behaviours. In the future, if we decide to change the UX, we\r\n    // can remove this prop.\r\n    setSubmit(method: PaymentMethod, fn: ((values: PaymentFormValues) => void) | null): void;\r\n    setValidationSchema(\r\n        method: PaymentMethod,\r\n        schema: ObjectSchema<Partial<PaymentFormValues>> | null,\r\n    ): void;\r\n    hidePaymentSubmitButton(method: PaymentMethod, hidden?: boolean): void;\r\n}\r\n\r\nconst PaymentContext = createContext<PaymentContextProps | undefined>(undefined);\r\n\r\nexport default PaymentContext;\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport TermsConditionsField, { TermsConditionsType } from './TermsConditionsField';\r\n\r\nexport interface TermsConditionsProps {\r\n    termsConditionsText?: string;\r\n    termsConditionsUrl?: string;\r\n}\r\n\r\nexport const TermsConditions: FunctionComponent<TermsConditionsProps> = ({\r\n    termsConditionsUrl,\r\n    termsConditionsText = '',\r\n}) => (\r\n    <>\r\n        {termsConditionsUrl ? (\r\n            <TermsConditionsField\r\n                name=\"terms\"\r\n                type={TermsConditionsType.Link}\r\n                url={termsConditionsUrl}\r\n            />\r\n        ) : (\r\n            <TermsConditionsField\r\n                name=\"terms\"\r\n                terms={termsConditionsText}\r\n                type={TermsConditionsType.TextArea}\r\n            />\r\n        )}\r\n    </>\r\n);\r\n","import { LanguageService } from '@bigcommerce/checkout-sdk';\r\nimport { object, ObjectSchema, string, StringSchema } from 'yup';\r\n\r\nimport { PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\r\n\r\nimport { getTermsConditionsValidationSchema } from '../termsConditions';\r\n\r\nexport interface PaymentValidationSchemaOptions {\r\n    additionalValidation?: ObjectSchema<Partial<PaymentFormValues>>;\r\n    isTermsConditionsRequired: boolean;\r\n    language: LanguageService;\r\n}\r\n\r\nexport default function getPaymentValidationSchema({\r\n    additionalValidation,\r\n    isTermsConditionsRequired,\r\n    language,\r\n}: PaymentValidationSchemaOptions): ObjectSchema<PaymentFormValues> {\r\n    const schemaFields: {\r\n        paymentProviderRadio: StringSchema;\r\n    } = {\r\n        paymentProviderRadio: string().required(),\r\n    };\r\n\r\n    const schemaFieldsWithTerms = object(schemaFields).concat(\r\n        getTermsConditionsValidationSchema({ isTermsConditionsRequired, language }),\r\n    );\r\n\r\n    return additionalValidation\r\n        ? schemaFieldsWithTerms.concat(additionalValidation as any)\r\n        : schemaFieldsWithTerms;\r\n}\r\n","import { LanguageService } from '@bigcommerce/checkout-sdk';\r\nimport { boolean, BooleanSchema, object, ObjectSchema } from 'yup';\r\n\r\nexport interface TermsConditionValidationSchemaOptions {\r\n    isTermsConditionsRequired: boolean;\r\n    language: LanguageService;\r\n}\r\n\r\nexport default function getTermsConditionsValidationSchema({\r\n    isTermsConditionsRequired,\r\n    language,\r\n}: TermsConditionValidationSchemaOptions): ObjectSchema<{ terms?: boolean }> {\r\n    const schemaFields: {\r\n        terms?: BooleanSchema;\r\n    } = {};\r\n\r\n    if (isTermsConditionsRequired) {\r\n        schemaFields.terms = boolean().oneOf(\r\n            [true],\r\n            language.translate('terms_and_conditions.agreement_required_error'),\r\n        );\r\n    }\r\n\r\n    return object(schemaFields);\r\n}\r\n","enum PaymentMethodType {\r\n    ApplePay = 'applepay',\r\n    Barclaycard = 'barclaycard',\r\n    CreditCard = 'credit-card',\r\n    GooglePay = 'googlepay',\r\n    PayWithGoogle = 'paywithgoogle',\r\n    Masterpass = 'masterpass',\r\n    MultiOption = 'multi-option',\r\n    Paypal = 'paypal',\r\n    PaypalCredit = 'paypal-credit',\r\n    PaypalVenmo = 'paypal-venmo',\r\n    VisaCheckout = 'visa-checkout',\r\n}\r\n\r\nexport default PaymentMethodType;\r\n","import { LanguageService, PaymentMethod } from '@bigcommerce/checkout-sdk';\r\nimport { capitalize, get } from 'lodash';\r\n\r\nimport PaymentMethodId from './PaymentMethodId';\r\nimport PaymentMethodType from './PaymentMethodType';\r\n\r\n/**\r\n * Always return the translated name of a payment method unless it is a\r\n * multi-option payment method or it doesn't have any translation. It's possible\r\n * to translate the gateway name of multi-option methods, i.e.: AfterPay.\r\n * However, because the options provided by the gateway can vary a lot, i.e.:\r\n * \"Pay by Installment\", therefore it's not feasible to do the translation on\r\n * the UI level.\r\n */\r\nexport default function getPaymentMethodName(\r\n    language: LanguageService,\r\n): (method: PaymentMethod) => string {\r\n    return (method) => {\r\n        let name = getTranslatedPaymentMethodName(language)(method);\r\n\r\n        if (!name || method.method === PaymentMethodType.MultiOption) {\r\n            name = method.config && method.config.displayName;\r\n        }\r\n\r\n        if (!name) {\r\n            name = capitalize(\r\n                // FIXME: I'm not entirely sure why we have to do this. But for some\r\n                // reason this is required for Masterpass provided by Square.\r\n                get(method, 'initializationData.paymentData.cardData.digital_wallet_type') ||\r\n                    method.method ||\r\n                    method.id,\r\n            );\r\n        }\r\n\r\n        return name;\r\n    };\r\n}\r\n\r\nexport function getTranslatedPaymentMethodName(\r\n    language: LanguageService,\r\n): (method: PaymentMethod) => string | undefined {\r\n    return (method) => {\r\n        const translations: { [key: string]: string } = {\r\n            [PaymentMethodId.Affirm]: language.translate('payment.affirm_name_text'),\r\n            [PaymentMethodId.Afterpay]: language.translate('payment.afterpay_name_text'),\r\n            [PaymentMethodId.AmazonPay]: language.translate('payment.amazon_name_text'),\r\n            [PaymentMethodId.Bolt]: language.translate('payment.bolt_name_text'),\r\n            [PaymentMethodId.Clearpay]: language.translate('payment.clearpay_name_text'),\r\n            [PaymentMethodType.GooglePay]: language.translate('payment.google_pay_name_text'),\r\n            [PaymentMethodId.Klarna]: language.translate('payment.klarna_name_text'),\r\n            [PaymentMethodType.Paypal]: language.translate('payment.paypal_name_text'),\r\n            [PaymentMethodType.PaypalCredit]: language.translate('payment.paypal_credit_name_text'),\r\n            [PaymentMethodType.VisaCheckout]: language.translate('payment.vco_name_text'),\r\n        };\r\n\r\n        return translations[method.id] || translations[method.method];\r\n    };\r\n}\r\n","import React, { FunctionComponent, memo } from 'react';\r\n\r\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\r\n\r\nimport { withCheckout } from '../checkout';\r\nimport { Button, ButtonSize, ButtonVariant } from '../ui/button';\r\nimport { IconBolt } from '../ui/icon';\r\n\r\nimport { PaymentMethodId, PaymentMethodType } from './paymentMethod';\r\n\r\ninterface PaymentSubmitButtonTextProps {\r\n    methodGateway?: string;\r\n    methodId?: string;\r\n    methodType?: string;\r\n    methodName?: string;\r\n    initialisationStrategyType?: string;\r\n    brandName?: string;\r\n    isComplete?: boolean;\r\n    isPaymentDataRequired?: boolean;\r\n}\r\n\r\nconst providersWithCustomClasses = [PaymentMethodId.Bolt];\r\n\r\nconst PaymentSubmitButtonText: FunctionComponent<PaymentSubmitButtonTextProps> = memo(\r\n    ({\r\n        methodId,\r\n        methodName,\r\n        methodType,\r\n        methodGateway,\r\n        initialisationStrategyType,\r\n        brandName,\r\n        isComplete,\r\n        isPaymentDataRequired,\r\n    }) => {\r\n        if (!isPaymentDataRequired) {\r\n            return <TranslatedString id=\"payment.place_order_action\" />;\r\n        }\r\n\r\n        if (methodName && initialisationStrategyType === 'none') {\r\n            return <TranslatedString data={{ methodName }} id=\"payment.ppsdk_continue_action\" />;\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.AmazonPay) {\r\n            return <TranslatedString id=\"payment.amazonpay_continue_action\" />;\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.Bolt) {\r\n            return (\r\n                <>\r\n                    <IconBolt additionalClassName=\"payment-submit-button-bolt-icon\" />\r\n                    <TranslatedString id=\"payment.place_order_action\" />\r\n                </>\r\n            );\r\n        }\r\n\r\n        if (methodGateway === PaymentMethodId.Barclaycard) {\r\n            return <TranslatedString id=\"payment.barclaycard_continue_action\" />;\r\n        }\r\n\r\n        if (methodGateway === PaymentMethodId.BlueSnapV2) {\r\n            return <TranslatedString id=\"payment.bluesnap_v2_continue_action\" />;\r\n        }\r\n\r\n        if (methodType === PaymentMethodType.VisaCheckout) {\r\n            return <TranslatedString id=\"payment.visa_checkout_continue_action\" />;\r\n        }\r\n\r\n        if (\r\n            methodType === PaymentMethodType.PaypalVenmo ||\r\n            methodId === PaymentMethodId.BraintreeVenmo\r\n        ) {\r\n            return <TranslatedString id=\"payment.paypal_venmo_continue_action\" />;\r\n        }\r\n\r\n        if (methodType === PaymentMethodType.Paypal) {\r\n            const continueActionId = methodId === PaymentMethodId.PaypalCommerce\r\n                ? 'payment.place_order_action'\r\n                : 'payment.paypal_continue_action';\r\n\r\n            return <TranslatedString\r\n                data={{ isComplete }}\r\n                id={isComplete ? 'payment.paypal_complete_action' : continueActionId}\r\n            />;\r\n        }\r\n\r\n        if (methodType === PaymentMethodType.PaypalCredit) {\r\n            const continueTranslationId = brandName\r\n                ? 'payment.continue_with_brand'\r\n                : 'payment.paypal_pay_later_continue_action'\r\n            const completeTranslationId = brandName\r\n                ? 'payment.complete_with_brand'\r\n                : 'payment.paypal_pay_later_complete_action'\r\n\r\n            return (\r\n                <TranslatedString\r\n                    data={{ brandName, isComplete, continueTranslationId, completeTranslationId }}\r\n                    id={\r\n                        isComplete\r\n                            ? completeTranslationId\r\n                            : continueTranslationId\r\n                    }\r\n                />\r\n            );\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.Opy) {\r\n            return <TranslatedString data={{ methodName }} id=\"payment.opy_continue_action\" />;\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.Quadpay) {\r\n            return <TranslatedString id=\"payment.quadpay_continue_action\" />;\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.Zip) {\r\n            return <TranslatedString id=\"payment.zip_continue_action\" />;\r\n        }\r\n\r\n        if (methodId === PaymentMethodId.Klarna) {\r\n            return <TranslatedString id=\"payment.klarna_continue_action\" />;\r\n        }\r\n\r\n        return <TranslatedString id=\"payment.place_order_action\" />;\r\n    },\r\n);\r\n\r\nexport interface PaymentSubmitButtonProps {\r\n    methodGateway?: string;\r\n    methodId?: string;\r\n    methodName?: string;\r\n    methodType?: string;\r\n    isDisabled?: boolean;\r\n    initialisationStrategyType?: string;\r\n    brandName?: string;\r\n    isComplete?: boolean;\r\n    isPaymentDataRequired?: boolean;\r\n}\r\n\r\ninterface WithCheckoutPaymentSubmitButtonProps {\r\n    isInitializing?: boolean;\r\n    isSubmitting?: boolean;\r\n}\r\n\r\nconst PaymentSubmitButton: FunctionComponent<\r\n    PaymentSubmitButtonProps & WithCheckoutPaymentSubmitButtonProps\r\n> = ({\r\n    isDisabled,\r\n    isInitializing,\r\n    isSubmitting,\r\n    isPaymentDataRequired,\r\n    methodGateway,\r\n    methodId,\r\n    methodName,\r\n    methodType,\r\n    initialisationStrategyType,\r\n    brandName,\r\n    isComplete,\r\n}) => (\r\n    <Button\r\n        className={\r\n            providersWithCustomClasses.includes(methodId as PaymentMethodId)\r\n                ? `payment-submit-button-${methodId}`\r\n                : undefined\r\n        }\r\n        data-test=\"payment-submit-button\"\r\n        disabled={isInitializing || isSubmitting || isDisabled}\r\n        id=\"checkout-payment-continue\"\r\n        isFullWidth\r\n        isLoading={isSubmitting}\r\n        size={ButtonSize.Large}\r\n        type=\"submit\"\r\n        variant={ButtonVariant.Action}\r\n    >\r\n        <PaymentSubmitButtonText\r\n            brandName={brandName}\r\n            initialisationStrategyType={initialisationStrategyType}\r\n            isComplete={isComplete}\r\n            isPaymentDataRequired={isPaymentDataRequired}\r\n            methodGateway={methodGateway}\r\n            methodId={methodId}\r\n            methodName={methodName}\r\n            methodType={methodType}\r\n        />\r\n    </Button>\r\n);\r\n\r\nexport default withCheckout(({ checkoutState }) => {\r\n    const {\r\n        data: { isPaymentDataRequired },\r\n        statuses: { isInitializingCustomer, isInitializingPayment, isSubmittingOrder },\r\n    } = checkoutState;\r\n\r\n    return {\r\n        isInitializing: isInitializingCustomer() || isInitializingPayment(),\r\n        isPaymentDataRequired: isPaymentDataRequired(),\r\n        isSubmitting: isSubmittingOrder(),\r\n    };\r\n})(memo(PaymentSubmitButton));\r\n","import { CheckoutSelectors } from '@bigcommerce/checkout-sdk';\r\nimport { noop } from 'lodash';\r\nimport React, { Component, MouseEvent, ReactNode } from 'react';\r\n\r\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\r\nimport { CheckoutContextProps } from '@bigcommerce/checkout/payment-integration-api';\r\n\r\nimport { withCheckout } from '../checkout';\r\nimport { isErrorWithType } from '../common/error';\r\nimport { LoadingOverlay } from '../ui/loading';\r\n\r\nexport interface SpamProtectionProps {\r\n    didExceedSpamLimit?: boolean;\r\n    onUnhandledError?(error: Error): void;\r\n}\r\n\r\ninterface SpamProtectionState {\r\n    shouldShowRetryButton: boolean;\r\n}\r\n\r\ninterface WithCheckoutSpamProtectionProps {\r\n    isExecutingSpamCheck: boolean;\r\n    executeSpamCheck(): Promise<CheckoutSelectors>;\r\n}\r\n\r\nfunction mapToSpamProtectionProps({\r\n    checkoutService,\r\n    checkoutState,\r\n}: CheckoutContextProps): WithCheckoutSpamProtectionProps {\r\n    return {\r\n        isExecutingSpamCheck: checkoutState.statuses.isExecutingSpamCheck(),\r\n        executeSpamCheck: checkoutService.executeSpamCheck,\r\n    };\r\n}\r\n\r\nclass SpamProtectionField extends Component<\r\n    SpamProtectionProps & WithCheckoutSpamProtectionProps,\r\n    SpamProtectionState\r\n> {\r\n    state = {\r\n        shouldShowRetryButton: false,\r\n    };\r\n\r\n    async componentDidMount() {\r\n        const { didExceedSpamLimit } = this.props;\r\n\r\n        if (didExceedSpamLimit) {\r\n            return;\r\n        }\r\n\r\n        this.verify();\r\n    }\r\n\r\n    render() {\r\n        const { isExecutingSpamCheck } = this.props;\r\n\r\n        return (\r\n            <div className=\"spamProtection-container\">\r\n                <LoadingOverlay isLoading={isExecutingSpamCheck}>\r\n                    {this.renderContent()}\r\n                </LoadingOverlay>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderContent(): ReactNode {\r\n        const { didExceedSpamLimit } = this.props;\r\n        const { shouldShowRetryButton } = this.state;\r\n\r\n        if (!didExceedSpamLimit && !shouldShowRetryButton) {\r\n            return;\r\n        }\r\n\r\n        return (\r\n            <div className=\"spamProtection-panel optimizedCheckout-overlay\">\r\n                <a\r\n                    className=\"spamProtection-panel-message optimizedCheckout-primaryContent\"\r\n                    data-test=\"spam-protection-verify-button\"\r\n                    onClick={this.handleRetry}\r\n                >\r\n                    <TranslatedString id=\"spam_protection.verify_action\" />\r\n                </a>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private async verify(): Promise<void> {\r\n        const { executeSpamCheck, onUnhandledError = noop } = this.props;\r\n\r\n        try {\r\n            await executeSpamCheck();\r\n        } catch (error) {\r\n            this.setState({ shouldShowRetryButton: true });\r\n\r\n            // Notify the parent component if the user experiences a problem other than cancelling the reCaptcha challenge.\r\n            if (\r\n                isErrorWithType(error) &&\r\n                error.type !== 'spam_protection_challenge_not_completed'\r\n            ) {\r\n                onUnhandledError(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleRetry: (event: MouseEvent) => void = (event) => {\r\n        event.preventDefault();\r\n\r\n        this.verify();\r\n    };\r\n}\r\n\r\nexport default withCheckout(mapToSpamProtectionProps)(SpamProtectionField);\r\n","import { PaymentMethod } from '@bigcommerce/checkout-sdk';\r\nimport { FormikProps, withFormik, WithFormikConfig } from 'formik';\r\nimport { isNil, noop, omitBy } from 'lodash';\r\nimport React, { FunctionComponent, memo, useMemo } from 'react';\r\n// import React, { FunctionComponent, memo, useCallback, useContext, useMemo } from 'react';\r\nimport { ObjectSchema } from 'yup';\r\n\r\nimport { withLanguage, WithLanguageProps } from '@bigcommerce/checkout/locale';\r\nimport { PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\r\n// import { FormContext } from '@bigcommerce/checkout/ui';\r\n\r\nimport { TermsConditions } from '../termsConditions';\r\nimport { Form } from '../ui/form';\r\n// import { Fieldset, Form } from '../ui/form';\r\n\r\nimport getPaymentValidationSchema from './getPaymentValidationSchema';\r\nimport {\r\n    getPaymentMethodName,\r\n    getUniquePaymentMethodId,\r\n    PaymentMethodId,\r\n    // PaymentMethodList,\r\n} from './paymentMethod';\r\n// import PaymentRedeemables from './PaymentRedeemables';\r\nimport PaymentSubmitButton from './PaymentSubmitButton';\r\nimport SpamProtectionField from './SpamProtectionField';\r\n// import { StoreCreditOverlay } from './storeCredit';\r\n// import { StoreCreditField, StoreCreditOverlay } from './storeCredit'; If something doesn't work, revert to this import when undoing changes.\r\n\r\nexport interface PaymentFormProps {\r\n    availableStoreCredit?: number;\r\n    defaultGatewayId?: string;\r\n    defaultMethodId: string;\r\n    didExceedSpamLimit?: boolean;\r\n    isEmbedded?: boolean;\r\n    isInitializingPayment?: boolean;\r\n    isTermsConditionsRequired?: boolean;\r\n    isUsingMultiShipping?: boolean;\r\n    isStoreCreditApplied: boolean;\r\n    methods: PaymentMethod[];\r\n    selectedMethod?: PaymentMethod;\r\n    shouldShowStoreCredit?: boolean;\r\n    shouldDisableSubmit?: boolean;\r\n    shouldHidePaymentSubmitButton?: boolean;\r\n    shouldExecuteSpamCheck?: boolean;\r\n    termsConditionsText?: string;\r\n    termsConditionsUrl?: string;\r\n    usableStoreCredit?: number;\r\n    validationSchema?: ObjectSchema<Partial<PaymentFormValues>>;\r\n    isPaymentDataRequired(): boolean;\r\n    onMethodSelect?(method: PaymentMethod): void;\r\n    onStoreCreditChange?(useStoreCredit?: boolean): void;\r\n    onSubmit?(values: PaymentFormValues): void;\r\n    onUnhandledError?(error: Error): void;\r\n}\r\n\r\nconst PaymentForm: FunctionComponent<\r\n    PaymentFormProps & FormikProps<PaymentFormValues> & WithLanguageProps\r\n> = ({\r\n    // availableStoreCredit = 0,\r\n    didExceedSpamLimit,\r\n    // isEmbedded,\r\n    // isInitializingPayment,\r\n    // isPaymentDataRequired,\r\n    isTermsConditionsRequired,\r\n    // isStoreCreditApplied,\r\n    // isUsingMultiShipping,\r\n    language,\r\n    // methods,\r\n    // onMethodSelect,\r\n    // onStoreCreditChange,\r\n    onUnhandledError,\r\n    // resetForm,\r\n    selectedMethod,\r\n    shouldDisableSubmit,\r\n    shouldHidePaymentSubmitButton,\r\n    shouldExecuteSpamCheck,\r\n    termsConditionsText = '',\r\n    termsConditionsUrl,\r\n    // usableStoreCredit = 0,\r\n    // values,\r\n}) => {\r\n    const selectedMethodId = useMemo(() => {\r\n        if (!selectedMethod) {\r\n            return;\r\n        }\r\n\r\n        switch (selectedMethod.id) {\r\n            case PaymentMethodId.AmazonPay:\r\n                if (selectedMethod.initializationData.paymentToken) {\r\n                    return;\r\n                }\r\n\r\n                return selectedMethod.id;\r\n\r\n            default:\r\n                return selectedMethod.id;\r\n        }\r\n    }, [selectedMethod]);\r\n\r\n    const brandName = useMemo(() => {\r\n        if (!selectedMethod) {\r\n            return;\r\n        }\r\n\r\n        return (\r\n            selectedMethod.initializationData?.payPalCreditProductBrandName?.credit ||\r\n            selectedMethod.initializationData?.payPalCreditProductBrandName\r\n        );\r\n    }, [selectedMethod]);\r\n\r\n    if (shouldExecuteSpamCheck) {\r\n        return (\r\n            <SpamProtectionField\r\n                didExceedSpamLimit={didExceedSpamLimit}\r\n                onUnhandledError={onUnhandledError}\r\n            />\r\n        );\r\n    }\r\n\r\n    return (\r\n        <Form className=\"checkout-form\" testId=\"payment-form\">\r\n            {/* {usableStoreCredit > 0 && (\r\n                <StoreCreditField\r\n                    availableStoreCredit={availableStoreCredit}\r\n                    isStoreCreditApplied={isStoreCreditApplied}\r\n                    name=\"useStoreCredit\"\r\n                    onChange={onStoreCreditChange}\r\n                    usableStoreCredit={usableStoreCredit}\r\n                />\r\n            )} */}\r\n\r\n            {/* <PaymentMethodListFieldset\r\n                isEmbedded={isEmbedded}\r\n                isInitializingPayment={isInitializingPayment}\r\n                isPaymentDataRequired={isPaymentDataRequired}\r\n                isUsingMultiShipping={isUsingMultiShipping}\r\n                methods={methods}\r\n                onMethodSelect={onMethodSelect}\r\n                onUnhandledError={onUnhandledError}\r\n                resetForm={resetForm}\r\n                values={values}\r\n            /> */}\r\n\r\n            {/* <PaymentRedeemables /> */}\r\n\r\n            {isTermsConditionsRequired && (\r\n                <TermsConditions\r\n                    termsConditionsText={termsConditionsText}\r\n                    termsConditionsUrl={termsConditionsUrl}\r\n                />\r\n            )}\r\n\r\n            <div className=\"form-actions\">\r\n                <div className='optimizedCheckout-callToAction'>\r\n                    Once a request is submitted, a SmallSat Catalog sales engineer will contact you with information, questions, or quotes within 2 to 3 business days.\r\n                </div>\r\n                {shouldHidePaymentSubmitButton ? (\r\n                    <PaymentMethodSubmitButtonContainer />\r\n                ) : (\r\n                    <PaymentSubmitButton    \r\n                        brandName={brandName}\r\n                        initialisationStrategyType={\r\n                            selectedMethod && selectedMethod.initializationStrategy?.type\r\n                        }\r\n                        isComplete={!!selectedMethod?.initializationData?.isComplete}\r\n                        isDisabled={shouldDisableSubmit}\r\n                        methodGateway={selectedMethod && selectedMethod.gateway}\r\n                        methodId={selectedMethodId}\r\n                        methodName={\r\n                            selectedMethod && getPaymentMethodName(language)(selectedMethod)\r\n                        }\r\n                        methodType={selectedMethod && selectedMethod.method}\r\n                    />\r\n                )}\r\n            </div>\r\n        </Form>\r\n    );\r\n};\r\n\r\nconst PaymentMethodSubmitButtonContainer: FunctionComponent = () => {\r\n    return <div className=\"submitButtonContainer\" id=\"checkout-payment-continue\" />;\r\n};\r\n\r\n// interface PaymentMethodListFieldsetProps {\r\n//     isEmbedded?: boolean;\r\n//     isInitializingPayment?: boolean;\r\n//     isUsingMultiShipping?: boolean;\r\n//     methods: PaymentMethod[];\r\n//     values: PaymentFormValues;\r\n//     isPaymentDataRequired(): boolean;\r\n//     onMethodSelect?(method: PaymentMethod): void;\r\n//     onUnhandledError?(error: Error): void;\r\n//     resetForm(nextValues?: PaymentFormValues): void;\r\n// }\r\n\r\n// const PaymentMethodListFieldset: FunctionComponent<PaymentMethodListFieldsetProps> = ({\r\n//     isEmbedded,\r\n//     isInitializingPayment,\r\n//     isPaymentDataRequired,\r\n//     isUsingMultiShipping,\r\n//     methods,\r\n//     onMethodSelect = noop,\r\n//     onUnhandledError,\r\n//     resetForm,\r\n//     values,\r\n// }) => {\r\n//     const { setSubmitted } = useContext(FormContext);\r\n\r\n//     const commonValues = useMemo(() => ({ terms: values.terms }), [values.terms]);\r\n\r\n//     const handlePaymentMethodSelect = useCallback(\r\n//         (method: PaymentMethod) => {\r\n//             resetForm({\r\n//                 ...commonValues,\r\n//                 ccCustomerCode: '',\r\n//                 ccCvv: '',\r\n//                 ccDocument: '',\r\n//                 customerEmail: '',\r\n//                 customerMobile: '',\r\n//                 ccExpiry: '',\r\n//                 ccName: '',\r\n//                 ccNumber: '',\r\n//                 instrumentId: '',\r\n//                 paymentProviderRadio: getUniquePaymentMethodId(method.id, method.gateway),\r\n//                 shouldCreateAccount: true,\r\n//                 shouldSaveInstrument: false,\r\n//                 accountNumber: '',\r\n//                 routingNumber: '',\r\n//             });\r\n\r\n//             setSubmitted(false);\r\n//             onMethodSelect(method);\r\n//         },\r\n//         [commonValues, onMethodSelect, resetForm, setSubmitted],\r\n//     );\r\n\r\n//     return (\r\n//         <Fieldset>\r\n//             {!isPaymentDataRequired() && <StoreCreditOverlay />}\r\n\r\n//             <PaymentMethodList\r\n//                 isEmbedded={isEmbedded}\r\n//                 isInitializingPayment={isInitializingPayment}\r\n//                 isUsingMultiShipping={isUsingMultiShipping}\r\n//                 methods={methods}\r\n//                 onSelect={handlePaymentMethodSelect}\r\n//                 onUnhandledError={onUnhandledError}\r\n//             />\r\n//         </Fieldset>\r\n//     );\r\n// };\r\n\r\nconst paymentFormConfig: WithFormikConfig<PaymentFormProps & WithLanguageProps, PaymentFormValues> =\r\n    {\r\n        mapPropsToValues: ({ defaultGatewayId, defaultMethodId }) => ({\r\n            ccCustomerCode: '',\r\n            ccCvv: '',\r\n            ccDocument: '',\r\n            customerEmail: '',\r\n            customerMobile: '',\r\n            ccExpiry: '',\r\n            ccName: '',\r\n            ccNumber: '',\r\n            paymentProviderRadio: getUniquePaymentMethodId(defaultMethodId, defaultGatewayId),\r\n            instrumentId: '',\r\n            shouldCreateAccount: true,\r\n            shouldSaveInstrument: false,\r\n            terms: false,\r\n            hostedForm: {\r\n                cardType: '',\r\n                errors: {\r\n                    cardCode: '',\r\n                    cardCodeVerification: '',\r\n                    cardExpiry: '',\r\n                    cardName: '',\r\n                    cardNumber: '',\r\n                    cardNumberVerification: '',\r\n                },\r\n            },\r\n            accountNumber: '',\r\n            routingNumber: '',\r\n        }),\r\n\r\n        handleSubmit: (values, { props: { onSubmit = noop } }) => {\r\n            onSubmit(\r\n                omitBy(\r\n                    values,\r\n                    (value, key) => isNil(value) || value === '' || key === 'hostedForm',\r\n                ),\r\n            );\r\n        },\r\n\r\n        validationSchema: ({\r\n            language,\r\n            isTermsConditionsRequired = false,\r\n            validationSchema,\r\n        }: PaymentFormProps & WithLanguageProps) =>\r\n            getPaymentValidationSchema({\r\n                additionalValidation: validationSchema,\r\n                isTermsConditionsRequired,\r\n                language,\r\n            }),\r\n    };\r\n\r\nexport default withLanguage(withFormik(paymentFormConfig)(memo(PaymentForm)));\r\n","enum PaymentMethodProviderType {\r\n    Api = 'PAYMENT_TYPE_API',\r\n    Hosted = 'PAYMENT_TYPE_HOSTED',\r\n    Offline = 'PAYMENT_TYPE_OFFLINE',\r\n    PPSDK = 'PAYMENT_TYPE_SDK',\r\n}\r\n\r\nexport default PaymentMethodProviderType;\r\n","import {\r\n    CartChangedError,\r\n    CheckoutSelectors,\r\n    CheckoutService,\r\n    CheckoutSettings,\r\n    OrderRequestBody,\r\n    PaymentMethod,\r\n} from '@bigcommerce/checkout-sdk';\r\nimport { memoizeOne } from '@bigcommerce/memoize';\r\nimport { compact, find, isEmpty, noop } from 'lodash';\r\nimport React, { Component, ReactNode } from 'react';\r\nimport { ObjectSchema } from 'yup';\r\n\r\nimport { AnalyticsContextProps } from '@bigcommerce/checkout/analytics';\r\nimport { ErrorLogger } from '@bigcommerce/checkout/error-handling-utils';\r\nimport { withLanguage, WithLanguageProps } from '@bigcommerce/checkout/locale';\r\nimport { CheckoutContextProps, PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\r\nimport { ChecklistSkeleton } from '@bigcommerce/checkout/ui';\r\n\r\nimport { withAnalytics } from '../analytics';\r\nimport { withCheckout } from '../checkout';\r\nimport {\r\n    ErrorModal,\r\n    ErrorModalOnCloseProps,\r\n    isCartChangedError,\r\n    isErrorWithType,\r\n} from '../common/error';\r\nimport { EMPTY_ARRAY } from '../common/utility';\r\nimport { TermsConditionsType } from '../termsConditions';\r\n\r\nimport mapSubmitOrderErrorMessage, { mapSubmitOrderErrorTitle } from './mapSubmitOrderErrorMessage';\r\nimport mapToOrderRequestBody from './mapToOrderRequestBody';\r\nimport PaymentContext from './PaymentContext';\r\nimport PaymentForm from './PaymentForm';\r\nimport {\r\n    getUniquePaymentMethodId,\r\n    PaymentMethodId,\r\n    PaymentMethodProviderType,\r\n} from './paymentMethod';\r\n\r\nexport interface PaymentProps {\r\n    errorLogger: ErrorLogger;\r\n    isEmbedded?: boolean;\r\n    isUsingMultiShipping?: boolean;\r\n    checkEmbeddedSupport?(methodIds: string[]): void; // TODO: We're currently doing this check in multiple places, perhaps we should move it up so this check get be done in a single place instead.\r\n    onCartChangedError?(error: CartChangedError): void;\r\n    onFinalize?(): void;\r\n    onFinalizeError?(error: Error): void;\r\n    onReady?(): void;\r\n    onSubmit?(): void;\r\n    onSubmitError?(error: Error): void;\r\n    onUnhandledError?(error: Error): void;\r\n}\r\n\r\ninterface WithCheckoutPaymentProps {\r\n    availableStoreCredit: number;\r\n    cartUrl: string;\r\n    defaultMethod?: PaymentMethod;\r\n    finalizeOrderError?: Error;\r\n    isInitializingPayment: boolean;\r\n    isSubmittingOrder: boolean;\r\n    isStoreCreditApplied: boolean;\r\n    isTermsConditionsRequired: boolean;\r\n    methods: PaymentMethod[];\r\n    shouldExecuteSpamCheck: boolean;\r\n    shouldLocaliseErrorMessages: boolean;\r\n    submitOrderError?: Error;\r\n    termsConditionsText?: string;\r\n    termsConditionsUrl?: string;\r\n    usableStoreCredit: number;\r\n    applyStoreCredit(useStoreCredit: boolean): Promise<CheckoutSelectors>;\r\n    clearError(error: Error): void;\r\n    finalizeOrderIfNeeded(): Promise<CheckoutSelectors>;\r\n    isPaymentDataRequired(): boolean;\r\n    loadCheckout(): Promise<CheckoutSelectors>;\r\n    loadPaymentMethods(): Promise<CheckoutSelectors>;\r\n    submitOrder(values: OrderRequestBody): Promise<CheckoutSelectors>;\r\n    checkoutServiceSubscribe: CheckoutService['subscribe'];\r\n}\r\n\r\ninterface PaymentState {\r\n    didExceedSpamLimit: boolean;\r\n    isReady: boolean;\r\n    selectedMethod?: PaymentMethod;\r\n    shouldDisableSubmit: { [key: string]: boolean };\r\n    shouldHidePaymentSubmitButton: { [key: string]: boolean };\r\n    submitFunctions: { [key: string]: ((values: PaymentFormValues) => void) | null };\r\n    validationSchemas: { [key: string]: ObjectSchema<Partial<PaymentFormValues>> | null };\r\n}\r\n\r\nclass Payment extends Component<\r\n    PaymentProps & WithCheckoutPaymentProps & WithLanguageProps & AnalyticsContextProps,\r\n    PaymentState\r\n> {\r\n    state: PaymentState = {\r\n        didExceedSpamLimit: false,\r\n        isReady: false,\r\n        shouldDisableSubmit: {},\r\n        shouldHidePaymentSubmitButton: {},\r\n        validationSchemas: {},\r\n        submitFunctions: {},\r\n    };\r\n\r\n    private grandTotalChangeUnsubscribe?: () => void;\r\n\r\n    private getContextValue = memoizeOne(() => {\r\n        return {\r\n            disableSubmit: this.disableSubmit,\r\n            setSubmit: this.setSubmit,\r\n            setValidationSchema: this.setValidationSchema,\r\n            hidePaymentSubmitButton: this.hidePaymentSubmitButton,\r\n        };\r\n    });\r\n\r\n    async componentDidMount(): Promise<void> {\r\n        const {\r\n            finalizeOrderIfNeeded,\r\n            onFinalize = noop,\r\n            onFinalizeError = noop,\r\n            onReady = noop,\r\n            usableStoreCredit,\r\n            checkoutServiceSubscribe,\r\n        } = this.props;\r\n\r\n\r\n        if (usableStoreCredit) {\r\n            this.handleStoreCreditChange(true);\r\n        }\r\n\r\n        await this.loadPaymentMethodsOrThrow();\r\n\r\n        try {\r\n            const state = await finalizeOrderIfNeeded();\r\n            const order = state.data.getOrder();\r\n\r\n            onFinalize(order?.orderId);\r\n        } catch (error) {\r\n            if (isErrorWithType(error) && error.type !== 'order_finalization_not_required') {\r\n                onFinalizeError(error);\r\n            }\r\n        }\r\n\r\n        this.grandTotalChangeUnsubscribe = checkoutServiceSubscribe(\r\n            () => this.handleCartTotalChange(),\r\n            ({ data }) => data.getCheckout()?.grandTotal,\r\n            ({ data }) => data.getCheckout()?.outstandingBalance,\r\n        );\r\n\r\n        window.addEventListener('beforeunload', this.handleBeforeUnload);\r\n        this.setState({ isReady: true });\r\n        onReady();\r\n    }\r\n\r\n    componentDidUpdate(): void {\r\n        const { checkEmbeddedSupport = noop, methods } = this.props;\r\n\r\n        checkEmbeddedSupport(methods.map(({ id }) => id));\r\n    }\r\n\r\n    componentWillUnmount(): void {\r\n        if (this.grandTotalChangeUnsubscribe) {\r\n            this.grandTotalChangeUnsubscribe();\r\n            this.grandTotalChangeUnsubscribe = undefined;\r\n        }\r\n\r\n        window.removeEventListener('beforeunload', this.handleBeforeUnload);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        const {\r\n            defaultMethod,\r\n            finalizeOrderError,\r\n            isInitializingPayment,\r\n            isUsingMultiShipping,\r\n            methods,\r\n            applyStoreCredit,\r\n            ...rest\r\n        } = this.props;\r\n\r\n        const {\r\n            didExceedSpamLimit,\r\n            isReady,\r\n            selectedMethod = defaultMethod,\r\n            shouldDisableSubmit,\r\n            validationSchemas,\r\n            shouldHidePaymentSubmitButton,\r\n        } = this.state;\r\n\r\n        const uniqueSelectedMethodId =\r\n            selectedMethod && getUniquePaymentMethodId(selectedMethod.id, selectedMethod.gateway);\r\n\r\n        return (\r\n            <PaymentContext.Provider value={this.getContextValue()}>\r\n                <ChecklistSkeleton isLoading={!isReady}>\r\n                    {!isEmpty(methods) && defaultMethod && (\r\n                        <PaymentForm\r\n                            {...rest}\r\n                            defaultGatewayId={defaultMethod.gateway}\r\n                            defaultMethodId={defaultMethod.id}\r\n                            didExceedSpamLimit={didExceedSpamLimit}\r\n                            isInitializingPayment={isInitializingPayment}\r\n                            isUsingMultiShipping={isUsingMultiShipping}\r\n                            isPaymentDataRequired={() => false}\r\n                            methods={methods}\r\n                            onMethodSelect={this.setSelectedMethod}\r\n                            onStoreCreditChange={this.handleStoreCreditChange}\r\n                            onSubmit={this.handleSubmit}\r\n                            onUnhandledError={this.handleError}\r\n                            selectedMethod={selectedMethod}\r\n                            shouldDisableSubmit={\r\n                                (uniqueSelectedMethodId &&\r\n                                    shouldDisableSubmit[uniqueSelectedMethodId]) ||\r\n                                undefined\r\n                            }\r\n                            shouldHidePaymentSubmitButton={\r\n                                (uniqueSelectedMethodId &&\r\n                                    rest.isPaymentDataRequired() &&\r\n                                    shouldHidePaymentSubmitButton[uniqueSelectedMethodId]) ||\r\n                                undefined\r\n                            }\r\n                            validationSchema={\r\n                                (uniqueSelectedMethodId &&\r\n                                    validationSchemas[uniqueSelectedMethodId]) ||\r\n                                undefined\r\n                            }\r\n                        />\r\n                    )}\r\n                </ChecklistSkeleton>\r\n\r\n                {this.renderOrderErrorModal()}\r\n                {this.renderEmbeddedSupportErrorModal()}\r\n            </PaymentContext.Provider>\r\n        );\r\n    }\r\n\r\n    private renderOrderErrorModal(): ReactNode {\r\n        const { finalizeOrderError, language, shouldLocaliseErrorMessages, submitOrderError } =\r\n            this.props;\r\n\r\n        // FIXME: Export correct TS interface\r\n        const error: any = submitOrderError || finalizeOrderError;\r\n\r\n        if (\r\n            !error ||\r\n            error.type === 'order_finalization_not_required' ||\r\n            error.type === 'payment_cancelled' ||\r\n            error.type === 'payment_invalid_form' ||\r\n            error.type === 'spam_protection_not_completed' ||\r\n            error.type === 'invalid_hosted_form_value'\r\n        ) {\r\n            return null;\r\n        }\r\n\r\n        return (\r\n            <ErrorModal\r\n                error={error}\r\n                message={mapSubmitOrderErrorMessage(\r\n                    error,\r\n                    language.translate.bind(language),\r\n                    shouldLocaliseErrorMessages,\r\n                )}\r\n                onClose={this.handleCloseModal}\r\n                title={mapSubmitOrderErrorTitle(error, language.translate.bind(language))}\r\n            />\r\n        );\r\n    }\r\n\r\n    private renderEmbeddedSupportErrorModal(): ReactNode {\r\n        const { checkEmbeddedSupport = noop, methods } = this.props;\r\n\r\n        try {\r\n            checkEmbeddedSupport(methods.map(({ id }) => id));\r\n        } catch (error) {\r\n            if (error instanceof Error) {\r\n                return <ErrorModal error={error} onClose={this.handleCloseModal} />;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private disableSubmit: (method: PaymentMethod, disabled?: boolean) => void = (\r\n        method,\r\n        disabled = true,\r\n    ) => {\r\n        const uniqueId = getUniquePaymentMethodId(method.id, method.gateway);\r\n        const { shouldDisableSubmit } = this.state;\r\n\r\n        if (shouldDisableSubmit[uniqueId] === disabled) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            shouldDisableSubmit: {\r\n                ...shouldDisableSubmit,\r\n                [uniqueId]: disabled,\r\n            },\r\n        });\r\n    };\r\n\r\n    private hidePaymentSubmitButton: (method: PaymentMethod, disabled?: boolean) => void = (\r\n        method,\r\n        disabled = true,\r\n    ) => {\r\n        const uniqueId = getUniquePaymentMethodId(method.id, method.gateway);\r\n        const { shouldHidePaymentSubmitButton } = this.state;\r\n\r\n        if (shouldHidePaymentSubmitButton[uniqueId] === disabled) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            shouldHidePaymentSubmitButton: {\r\n                ...shouldHidePaymentSubmitButton,\r\n                [uniqueId]: disabled,\r\n            },\r\n        });\r\n    };\r\n\r\n    // tslint:disable:cyclomatic-complexity\r\n    private handleBeforeUnload: (event: BeforeUnloadEvent) => string | undefined = (event) => {\r\n        const { defaultMethod, isSubmittingOrder, language } = this.props;\r\n        const { selectedMethod = defaultMethod } = this.state;\r\n\r\n        // TODO: Perhaps there is a better way to handle `adyen`, `afterpay`, `amazonpay`,\r\n        // `checkout.com`, `converge`, `sagepay`, `stripev3` and `sezzle`. They require\r\n        //  a redirection to another website during the payment flow but are not\r\n        //  categorised as hosted payment methods.\r\n        if (\r\n            !isSubmittingOrder ||\r\n            !selectedMethod ||\r\n            selectedMethod.type === PaymentMethodProviderType.Hosted ||\r\n            selectedMethod.type === PaymentMethodProviderType.PPSDK ||\r\n            selectedMethod.gateway === PaymentMethodId.BlueSnapDirect ||\r\n            selectedMethod.gateway === PaymentMethodId.BlueSnapV2 ||\r\n            selectedMethod.id === PaymentMethodId.AmazonPay ||\r\n            selectedMethod.id === PaymentMethodId.CBAMPGS ||\r\n            selectedMethod.id === PaymentMethodId.Checkoutcom ||\r\n            selectedMethod.id === PaymentMethodId.CheckoutcomGooglePay ||\r\n            selectedMethod.id === PaymentMethodId.Converge ||\r\n            selectedMethod.id === PaymentMethodId.Humm ||\r\n            selectedMethod.id === PaymentMethodId.Laybuy ||\r\n            selectedMethod.id === PaymentMethodId.Opy ||\r\n            selectedMethod.id === PaymentMethodId.Quadpay ||\r\n            selectedMethod.id === PaymentMethodId.SagePay ||\r\n            selectedMethod.id === PaymentMethodId.Sezzle ||\r\n            selectedMethod.id === PaymentMethodId.WorldpayAccess ||\r\n            selectedMethod.id === PaymentMethodId.Zip ||\r\n            selectedMethod.gateway === PaymentMethodId.AdyenV2 ||\r\n            selectedMethod.gateway === PaymentMethodId.AdyenV2GooglePay ||\r\n            selectedMethod.gateway === PaymentMethodId.AdyenV3 ||\r\n            selectedMethod.gateway === PaymentMethodId.AdyenV3GooglePay ||\r\n            selectedMethod.gateway === PaymentMethodId.Afterpay ||\r\n            selectedMethod.gateway === PaymentMethodId.Clearpay ||\r\n            selectedMethod.gateway === PaymentMethodId.Checkoutcom ||\r\n            selectedMethod.gateway === PaymentMethodId.Mollie ||\r\n            selectedMethod.gateway === PaymentMethodId.StripeV3\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const message = language.translate('common.leave_warning');\r\n\r\n        event.returnValue = message;\r\n\r\n        return message;\r\n    };\r\n\r\n    private handleCloseModal: (event: Event, props: ErrorModalOnCloseProps) => Promise<void> =\r\n        async (_, { error }) => {\r\n            if (!error) {\r\n                return;\r\n            }\r\n\r\n            const { cartUrl, clearError, loadCheckout } = this.props;\r\n            const { type: errorType } = error as any; // FIXME: Export correct TS interface\r\n\r\n            if (\r\n                errorType === 'provider_fatal_error' ||\r\n                errorType === 'order_could_not_be_finalized_error'\r\n            ) {\r\n                window.location.replace(cartUrl || '/');\r\n            }\r\n\r\n            if (errorType === 'tax_provider_unavailable') {\r\n                window.location.reload();\r\n            }\r\n\r\n            if (errorType === 'cart_consistency') {\r\n                await loadCheckout();\r\n            }\r\n\r\n            if (isErrorWithType(error) && error.body) {\r\n                const { body, headers, status } = error;\r\n\r\n                if (body.type === 'provider_error' && headers.location) {\r\n                    window.top?.location.assign(headers.location);\r\n                }\r\n\r\n                // Reload the checkout object to get the latest `shouldExecuteSpamCheck` value,\r\n                // which will in turn make `SpamProtectionField` visible again.\r\n                // NOTE: As a temporary fix, we're checking the status code instead of the error\r\n                // type because of an issue with Nginx config, which causes the server to return\r\n                // HTML page instead of JSON response when there is a 429 error.\r\n                if (\r\n                    status === 429 ||\r\n                    body.type === 'spam_protection_expired' ||\r\n                    body.type === 'spam_protection_failed'\r\n                ) {\r\n                    this.setState({ didExceedSpamLimit: true });\r\n\r\n                    await loadCheckout();\r\n                }\r\n            }\r\n\r\n            clearError(error);\r\n        };\r\n\r\n    private handleStoreCreditChange: (useStoreCredit: boolean) => void = async (useStoreCredit) => {\r\n        const { applyStoreCredit, onUnhandledError = noop } = this.props;\r\n\r\n        try {\r\n            await applyStoreCredit(useStoreCredit);\r\n        } catch (e) {\r\n            onUnhandledError(e);\r\n        }\r\n    };\r\n\r\n    private handleError: (error: Error) => void = (error: Error) => {\r\n        const { onUnhandledError = noop, errorLogger } = this.props;\r\n\r\n        const { type } = error as any;\r\n\r\n        if (type === 'unexpected_detachment') {\r\n            errorLogger.log(error);\r\n\r\n            return;\r\n        }\r\n\r\n        return onUnhandledError(error);\r\n    };\r\n\r\n    private handleSubmit: (values: PaymentFormValues) => void = async (values) => {\r\n        const {\r\n            defaultMethod,\r\n            loadPaymentMethods,\r\n            isPaymentDataRequired,\r\n            onCartChangedError = noop,\r\n            onSubmit = noop,\r\n            onSubmitError = noop,\r\n            submitOrder,\r\n            analyticsTracker\r\n        } = this.props;\r\n\r\n        const { selectedMethod = defaultMethod, submitFunctions } = this.state;\r\n\r\n        analyticsTracker.clickPayButton({shouldCreateAccount: values.shouldCreateAccount});\r\n\r\n        const customSubmit =\r\n            selectedMethod &&\r\n            submitFunctions[getUniquePaymentMethodId(selectedMethod.id, selectedMethod.gateway)];\r\n\r\n        if (customSubmit) {\r\n            return customSubmit(values);\r\n        }\r\n\r\n        try {\r\n            const state = await submitOrder(mapToOrderRequestBody(values, isPaymentDataRequired()));\r\n            const order = state.data.getOrder();\r\n\r\n            analyticsTracker.paymentComplete();\r\n\r\n            onSubmit(order?.orderId);\r\n        } catch (error) {\r\n            analyticsTracker.paymentRejected();\r\n\r\n            if (isErrorWithType(error) && error.type === 'payment_method_invalid') {\r\n                return loadPaymentMethods();\r\n            }\r\n\r\n            if (isCartChangedError(error)) {\r\n                return onCartChangedError(error);\r\n            }\r\n\r\n            onSubmitError(error);\r\n        }\r\n    };\r\n\r\n    private setSelectedMethod: (method?: PaymentMethod) => void = (method) => {\r\n        const { selectedMethod } = this.state;\r\n\r\n        if (selectedMethod === method) {\r\n            return;\r\n        }\r\n\r\n        if (method) {\r\n            this.trackSelectedPaymentMethod(method);\r\n        }\r\n\r\n        this.setState({ selectedMethod: method });\r\n    };\r\n\r\n    private setSubmit: (\r\n        method: PaymentMethod,\r\n        fn: (values: PaymentFormValues) => void | null,\r\n    ) => void = (method, fn) => {\r\n        const uniqueId = getUniquePaymentMethodId(method.id, method.gateway);\r\n        const { submitFunctions } = this.state;\r\n\r\n        if (submitFunctions[uniqueId] === fn) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            submitFunctions: {\r\n                ...submitFunctions,\r\n                [uniqueId]: fn,\r\n            },\r\n        });\r\n    };\r\n\r\n    private setValidationSchema: (\r\n        method: PaymentMethod,\r\n        schema: ObjectSchema<Partial<PaymentFormValues>> | null,\r\n    ) => void = (method, schema) => {\r\n        const uniqueId = getUniquePaymentMethodId(method.id, method.gateway);\r\n        const { validationSchemas } = this.state;\r\n\r\n        if (validationSchemas[uniqueId] === schema) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            validationSchemas: {\r\n                ...validationSchemas,\r\n                [uniqueId]: schema,\r\n            },\r\n        });\r\n    };\r\n\r\n    private trackSelectedPaymentMethod(method: PaymentMethod) {\r\n        const { analyticsTracker } = this.props;\r\n\r\n        const methodName = method.config.displayName || method.id;\r\n        const methodId = method.id;\r\n\r\n        analyticsTracker.selectedPaymentMethod(methodName, methodId);\r\n    }\r\n\r\n    private async loadPaymentMethodsOrThrow(): Promise<void> {\r\n        const {\r\n            loadPaymentMethods,\r\n            onUnhandledError = noop,\r\n        } = this.props;\r\n\r\n        try {\r\n            await loadPaymentMethods();\r\n\r\n            const selectedMethod = this.state.selectedMethod || this.props.defaultMethod;\r\n\r\n            if (selectedMethod) {\r\n                this.trackSelectedPaymentMethod(selectedMethod);\r\n            }\r\n        } catch (error) {\r\n            onUnhandledError(error);\r\n        }\r\n    }\r\n\r\n    private async handleCartTotalChange(): Promise<void> {\r\n        const { isReady } = this.state;\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.setState({ isReady: false });\r\n\r\n        await this.loadPaymentMethodsOrThrow();\r\n\r\n        this.setState({ isReady: true });\r\n    }\r\n}\r\n\r\nexport function mapToPaymentProps({\r\n        checkoutService,\r\n        checkoutState,\r\n}: CheckoutContextProps): WithCheckoutPaymentProps | null {\r\n    const {\r\n        data: {\r\n            getCheckout,\r\n            getConfig,\r\n            getCustomer,\r\n            getConsignments,\r\n            getOrder,\r\n            getPaymentMethod,\r\n            getPaymentMethods,\r\n            isPaymentDataRequired,\r\n            getPaymentProviderCustomer,\r\n        },\r\n        errors: { getFinalizeOrderError, getSubmitOrderError },\r\n        statuses: { isInitializingPayment, isSubmittingOrder },\r\n    } = checkoutState;\r\n\r\n    const checkout = getCheckout();\r\n    const config = getConfig();\r\n    const customer = getCustomer();\r\n    const consignments = getConsignments();\r\n    const paymentProviderCustomer = getPaymentProviderCustomer();\r\n\r\n    const { isComplete = false } = getOrder() || {};\r\n    let methods = getPaymentMethods() || EMPTY_ARRAY;\r\n\r\n    // TODO: In accordance with the checkout team, this functionality is temporary and will be implemented in the backend instead.\r\n    if (paymentProviderCustomer?.stripeLinkAuthenticationState) {\r\n        const stripeUpePaymentMethod = methods.filter(method =>\r\n            method.id === 'card' && method.gateway === PaymentMethodId.StripeUPE\r\n        );\r\n\r\n        methods = stripeUpePaymentMethod.length ? stripeUpePaymentMethod : methods;\r\n    }\r\n\r\n    if (!checkout || !config || !customer || isComplete) {\r\n        return null;\r\n    }\r\n\r\n    const {\r\n        enableTermsAndConditions: isTermsConditionsEnabled,\r\n        features,\r\n        orderTermsAndConditionsType: termsConditionsType,\r\n        orderTermsAndConditions: termsCondtitionsText,\r\n        orderTermsAndConditionsLink: termsCondtitionsUrl,\r\n    } = config.checkoutSettings as CheckoutSettings & { orderTermsAndConditionsLocation: string };\r\n\r\n    const isTermsConditionsRequired = isTermsConditionsEnabled;\r\n    const selectedPayment = find(checkout.payments, {\r\n        providerType: PaymentMethodProviderType.Hosted,\r\n    });\r\n\r\n    const { isStoreCreditApplied } = checkout;\r\n\r\n    let selectedPaymentMethod;\r\n    let filteredMethods;\r\n\r\n    filteredMethods = methods.filter((method: PaymentMethod) => {\r\n        if (method.id === PaymentMethodId.Bolt && method.initializationData) {\r\n            return !!method.initializationData.showInCheckout;\r\n        }\r\n\r\n        if (method.id === PaymentMethodId.BraintreeLocalPaymentMethod) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    });\r\n\r\n    if (consignments && consignments.length > 1) {\r\n        const multiShippingIncompatibleMethodIds: string[] = [\r\n            PaymentMethodId.AmazonPay,\r\n        ];\r\n\r\n        filteredMethods = methods.filter((method: PaymentMethod) => {\r\n            return multiShippingIncompatibleMethodIds.indexOf(method.id) === -1;\r\n        });\r\n    }\r\n\r\n    if (selectedPayment) {\r\n        selectedPaymentMethod = getPaymentMethod(\r\n            selectedPayment.providerId,\r\n            selectedPayment.gatewayId,\r\n        );\r\n        filteredMethods = selectedPaymentMethod\r\n            ? compact([selectedPaymentMethod])\r\n            : filteredMethods;\r\n    } else {\r\n        selectedPaymentMethod = find(filteredMethods, {\r\n            config: { hasDefaultStoredInstrument: true },\r\n        });\r\n        // eslint-disable-next-line no-self-assign\r\n        filteredMethods = filteredMethods;\r\n    }\r\n\r\n    return {\r\n        applyStoreCredit: checkoutService.applyStoreCredit,\r\n        availableStoreCredit: customer.storeCredit,\r\n        cartUrl: config.links.cartLink,\r\n        clearError: checkoutService.clearError,\r\n        defaultMethod: selectedPaymentMethod || filteredMethods[0],\r\n        finalizeOrderError: getFinalizeOrderError(),\r\n        finalizeOrderIfNeeded: checkoutService.finalizeOrderIfNeeded,\r\n        loadCheckout: checkoutService.loadCheckout,\r\n        isInitializingPayment: isInitializingPayment(),\r\n        isPaymentDataRequired,\r\n        isStoreCreditApplied,\r\n        isSubmittingOrder: isSubmittingOrder(),\r\n        isTermsConditionsRequired,\r\n        loadPaymentMethods: checkoutService.loadPaymentMethods,\r\n        methods: filteredMethods,\r\n        shouldExecuteSpamCheck: checkout.shouldExecuteSpamCheck,\r\n        shouldLocaliseErrorMessages:\r\n            features['PAYMENTS-6799.localise_checkout_payment_error_messages'],\r\n        submitOrder: checkoutService.submitOrder,\r\n        submitOrderError: getSubmitOrderError(),\r\n        checkoutServiceSubscribe: checkoutService.subscribe,\r\n        termsConditionsText:\r\n            isTermsConditionsRequired && termsConditionsType === TermsConditionsType.TextArea\r\n                ? termsCondtitionsText\r\n                : undefined,\r\n        termsConditionsUrl:\r\n            isTermsConditionsRequired && termsConditionsType === TermsConditionsType.Link\r\n                ? termsCondtitionsUrl\r\n                : undefined,\r\n        usableStoreCredit:\r\n            checkout.grandTotal > 0 ? Math.min(checkout.grandTotal, customer.storeCredit || 0) : 0,\r\n    };\r\n}\r\n\r\nexport default withAnalytics(withLanguage(withCheckout(mapToPaymentProps)(Payment)));\r\n","import { CartChangedError } from '@bigcommerce/checkout-sdk';\r\n\r\nexport default function isCartChangedError(error: unknown): error is CartChangedError {\r\n    const requestError = error as CartChangedError;\r\n\r\n    return requestError.type === 'cart_changed';\r\n}\r\n","import React, {\r\n    Component,\r\n    KeyboardEvent,\r\n    KeyboardEventHandler,\r\n    MouseEventHandler,\r\n    ReactNode,\r\n} from 'react';\r\n\r\nexport interface ModalTriggerProps {\r\n    children(props: { onClick: MouseEventHandler; onKeyPress: KeyboardEventHandler<HTMLDivElement> }): ReactNode;\r\n    modal(props: ModalTriggerModalProps): ReactNode;\r\n}\r\n\r\nexport interface ModalTriggerModalProps {\r\n    isOpen: boolean;\r\n    onRequestClose(): void;\r\n}\r\n\r\nexport interface ModalTriggerState {\r\n    isOpen: boolean;\r\n}\r\n\r\nexport default class ModalTrigger extends Component<ModalTriggerProps, ModalTriggerState> {\r\n    state = {\r\n        isOpen: false,\r\n    };\r\n\r\n    private canHandleEvent = false;\r\n\r\n    componentDidMount(): void {\r\n        this.canHandleEvent = true;\r\n    }\r\n\r\n    componentWillUnmount(): void {\r\n        this.canHandleEvent = false;\r\n    }\r\n\r\n    render() {\r\n        const { children, modal } = this.props;\r\n        const { isOpen } = this.state;\r\n\r\n        return (\r\n            <>\r\n                {children({\r\n                    onClick: this.handleOpen,\r\n                    onKeyPress: this.handleKeyOpen,\r\n                })}\r\n\r\n                {modal({\r\n                    isOpen,\r\n                    onRequestClose: this.handleClose,\r\n                })}\r\n            </>\r\n        );\r\n    }\r\n\r\n    private handleOpen: () => void = () => {\r\n        if (!this.canHandleEvent) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            isOpen: true,\r\n        });\r\n    };\r\n\r\n    private handleClose: () => void = () => {\r\n        if (!this.canHandleEvent) {\r\n            return;\r\n        }\r\n\r\n        this.setState({\r\n            isOpen: false,\r\n        });\r\n    };\r\n\r\n    private handleKeyOpen: (keyboardEvent: KeyboardEvent<HTMLElement>) => void = (\r\n        keyboardEvent,\r\n    ) => {\r\n        if (keyboardEvent.key === 'Enter') {\r\n            this.handleOpen();\r\n        }\r\n    };\r\n}\r\n"],"names":["children","body","header","renderModal","useCallback","props","Modal","additionalBodyClassName","footer","Button","onClick","onRequestClose","size","Small","TranslatedString","id","shouldShowCloseButton","ModalTrigger","modal","preventDefault","split","map","line","key","Fragment","TermsConditionsType","TermsConditionsModalCheckboxField","withLanguage","language","name","terms","translatedLabel","translate","url","parsedLabel","parseAnchor","labelContent","ModalHeader","CheckboxFormField","TermsConditionsCheckboxField","useMemo","TranslatedHtml","data","TermsConditionsTextField","renderInput","field","TextArea","defaultValue","readOnly","FormField","input","memo","type","Fieldset","additionalClassName","legend","Legend","isTermsConditionsTextArea","isTermsConditionModal","mapSubmitOrderErrorMessage","error","shouldLocalise","subtype","includes","message","errors","length","err","code","join","mapSubmitOrderErrorTitle","unformatCreditCardExpiryDate","value","RegExp","month","year","test","slice","getUniquePaymentMethodId","methodId","gatewayId","compact","hasCreditCardNumber","values","Object","hasCreditCardExpiry","mapToOrderRequestBody","isPaymentDataRequired","separator","paymentProviderRadio","rest","indexOf","undefined","parseUniquePaymentMethodId","payload","payment","paymentData","omitBy","ccExpiry","ccNumber","number","replace","isNil","isEmpty","createContext","TermsConditions","termsConditionsUrl","termsConditionsText","TermsConditionsField","Link","getPaymentValidationSchema","additionalValidation","isTermsConditionsRequired","schemaFields","required","schemaFieldsWithTerms","concat","oneOf","getTermsConditionsValidationSchema","PaymentMethodType","getPaymentMethodName","method","translations","PaymentMethodId","Affirm","Afterpay","AmazonPay","Bolt","Clearpay","GooglePay","Klarna","Paypal","PaypalCredit","VisaCheckout","getTranslatedPaymentMethodName","MultiOption","config","displayName","capitalize","get","providersWithCustomClasses","PaymentSubmitButtonText","methodName","methodType","methodGateway","initialisationStrategyType","brandName","isComplete","IconBolt","Barclaycard","BlueSnapV2","PaypalVenmo","BraintreeVenmo","continueActionId","PaypalCommerce","continueTranslationId","completeTranslationId","Opy","Quadpay","Zip","withCheckout","checkoutState","isInitializingCustomer","isInitializingPayment","isSubmittingOrder","isInitializing","isSubmitting","isDisabled","className","disabled","isFullWidth","isLoading","Large","variant","Action","state","shouldShowRetryButton","handleRetry","event","verify","componentDidMount","this","render","isExecutingSpamCheck","LoadingOverlay","renderContent","didExceedSpamLimit","executeSpamCheck","onUnhandledError","noop","setState","isErrorWithType","Component","checkoutService","statuses","SpamProtectionField","PaymentMethodSubmitButtonContainer","paymentFormConfig","mapPropsToValues","defaultGatewayId","ccCustomerCode","ccCvv","ccDocument","customerEmail","customerMobile","ccName","instrumentId","shouldCreateAccount","shouldSaveInstrument","hostedForm","cardType","cardCode","cardCodeVerification","cardExpiry","cardName","cardNumber","cardNumberVerification","accountNumber","routingNumber","handleSubmit","onSubmit","validationSchema","withFormik","selectedMethod","shouldDisableSubmit","shouldHidePaymentSubmitButton","shouldExecuteSpamCheck","selectedMethodId","initializationData","paymentToken","payPalCreditProductBrandName","credit","Form","testId","initializationStrategy","gateway","PaymentMethodProviderType","isReady","validationSchemas","submitFunctions","getContextValue","memoizeOne","disableSubmit","setSubmit","setValidationSchema","hidePaymentSubmitButton","uniqueId","handleBeforeUnload","defaultMethod","Hosted","PPSDK","BlueSnapDirect","CBAMPGS","Checkoutcom","CheckoutcomGooglePay","Converge","Humm","Laybuy","SagePay","Sezzle","WorldpayAccess","AdyenV2","AdyenV2GooglePay","AdyenV3","AdyenV3GooglePay","Mollie","StripeV3","returnValue","handleCloseModal","_","cartUrl","clearError","loadCheckout","errorType","window","location","reload","headers","top","assign","handleStoreCreditChange","useStoreCredit","applyStoreCredit","handleError","errorLogger","log","loadPaymentMethods","onCartChangedError","onSubmitError","submitOrder","analyticsTracker","clickPayButton","customSubmit","order","getOrder","paymentComplete","orderId","paymentRejected","setSelectedMethod","trackSelectedPaymentMethod","fn","schema","finalizeOrderIfNeeded","onFinalize","onFinalizeError","onReady","usableStoreCredit","checkoutServiceSubscribe","loadPaymentMethodsOrThrow","grandTotalChangeUnsubscribe","handleCartTotalChange","getCheckout","grandTotal","outstandingBalance","addEventListener","componentDidUpdate","checkEmbeddedSupport","componentWillUnmount","removeEventListener","isUsingMultiShipping","methods","uniqueSelectedMethodId","Provider","ChecklistSkeleton","defaultMethodId","onMethodSelect","onStoreCreditChange","renderOrderErrorModal","renderEmbeddedSupportErrorModal","finalizeOrderError","shouldLocaliseErrorMessages","ErrorModal","bind","onClose","title","Error","selectedPaymentMethod","mapToPaymentProps","getConfig","getCustomer","getConsignments","getPaymentMethod","getPaymentMethods","getPaymentProviderCustomer","getFinalizeOrderError","getSubmitOrderError","checkout","customer","consignments","paymentProviderCustomer","stripeLinkAuthenticationState","stripeUpePaymentMethod","filter","StripeUPE","filteredMethods","checkoutSettings","isTermsConditionsEnabled","features","termsConditionsType","termsCondtitionsText","termsCondtitionsUrl","selectedPayment","find","payments","providerType","isStoreCreditApplied","showInCheckout","BraintreeLocalPaymentMethod","providerId","hasDefaultStoredInstrument","availableStoreCredit","storeCredit","links","cartLink","submitOrderError","subscribe","Math","min","withAnalytics","Payment","isOpen","canHandleEvent","handleOpen","handleClose","handleKeyOpen","keyboardEvent","onKeyPress"],"sourceRoot":""}